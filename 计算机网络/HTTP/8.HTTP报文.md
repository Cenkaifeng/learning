<!-- TOC -->

- [序言](#序言)
- [报文结构](#报文结构)
- [请求行](#请求行)
- [状态行](#状态行)
- [头部字段](#头部字段)
- [常用头字段](#常用头字段)
- [小结](#小结)
- [问题](#问题)

<!-- /TOC -->

## 序言

HTTP 的核心部分是它的传输的报文内容

HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略

## 报文结构

TCP 在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。

有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据

![TCP报文结构](http://ww1.sinaimg.cn/large/68307314gy1gesy8t9y0kj22bc1ap7bm.jpg)

HTTP 也需要在实际传输的数据前附加一些头数据，不过是“纯文本”的协议，所以头数据都是 ASCII 码的文本，肉眼可读，不需要解析就能懂

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（start line）：描述请求或响应的基本信息
2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文
3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据

HTTP 协议规定报文必须有 header，但可以没有 body，而且 header 之后必须要有一个“空行”，也就是“CRLF”

![HTTP报文结构](http://ww1.sinaimg.cn/large/68307314gy1geszmfgbouj22bc1ap787.jpg)

Wireshark 抓包：
![抓包HTTP报文](http://ww1.sinaimg.cn/large/68307314gy1geszrpy2m0j20v807r74l.jpg)

## 请求行

请求行，描述了客户端想要如何操作服务器端的资源

请求行由三部分构成：

1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作
2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源
3. 版本号：表示报文使用的 HTTP 协议版本

这三部分通常用空格（space）来分割，最后用 CRLF 换行表示结束
![请求行](http://ww1.sinaimg.cn/large/68307314gy1get4sppfflj22bc0cvtaz.jpg)

用 Wireshark 抓包的数据来举例：

```http
GET / HTTP/1.1
```

在以上例子，“GET”是请求方法，“/”是请求目标，"HTTP/1.1"是版本号，连接起来的意思是“服务器，我想要获取网站根目录下的默认文件，用的是 HTTP/1.1 版本”

## 状态行

响应报文的起始行，叫“状态行（status line）”，意思是服务器响应的状态

同样是三部分构成：

1. 版本号：表示报文使用的 HTTP 协议版本
2. 状态码：一个三位数，用代码的姓氏表示处理的结果，比如 200 是成功，500 是服务器内部错误
3. 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因

![状态行](http://ww1.sinaimg.cn/large/68307314gy1get5fabsb8j22bc0d3n00.jpg)

Wireshark 抓包的响应报文：

```http
HTTP/1.1 200 OK
```

用通俗的话翻译过来的意思是，“已经处理完你的请求，这个报文使用协议版本号是 1.1，状态码是 200，一切 OK”

## 头部字段

以下是请求行和状态行加上头部字段的集合，构成的 HTTP 报文里完整的请求头和响应头：
![请求头和响应头](http://ww1.sinaimg.cn/large/68307314gy1get5rgb9q6j22bc10ijyz.jpg)

HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。

不过头字段有以下几点需要注意：

1. 字段名不区分大小写，例如“Host”等于“host”，首字母大写可读性更强

2. 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“\_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名

3. 字段名后必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格

4. 字段的顺序是没有意义的，可以任意排列不影响语义

5. 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie

## 常用头字段

HTTP 协议规定了非常多的头部字段，但基本上可以分为四大类：

1. 通用字段：在请求头和响应头里可以出现
2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件
3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息
4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息

几个基本的头字段：

- Host：  
  请求字段，只能出现在请求头里，在 HTTP/1.1 规范里要求必须出现的字段。Host 字段告诉服务器请求应该由哪个主机来处理

- User-Agent：  
  请求字段，只出现在请求头里，使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以一句他来返回最适合此浏览器显示的页面

  有时候，不能通过 User-Agent 判断是哪一款浏览器。不过有时候，“诚实”的爬虫会在 User-Agent 里用“spider”表明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略

- Date：  
  通用字段，通常出现在响应头，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略

- Server：  
  响应字段，只能出现在响应头李，告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。

- Content-Length：  
  表示报文里，请求头或响应头空行后数据的长度，也就是 body 的长度。服务器看到这个字段，就知道后续有多少数据，可以直接接收。如果没有这个字段，body 就是不定长，需要使用 chuncked 方式分段传输

## 小结

1. HTTP 报文结构由“起始行 + 头部 + 空行 + 实体”组成，简单地说就是“header + body”

2. HTTP 报文可以没有 body，但必须要有 header，而且 header 后也必须要有空行

3. 请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成

4. 请求行有三部分：请求方法、请求目标和版本号

5. 状态行有三部分：版本号、状态码和原因字符串

6. 头部字段是 key-value 形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展

7. HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名

## 问题

1. 如果拼 HTTP 报文的时候，在头字段后多家了一个 CRLF，导致出现了一个空行，会发生什么？  
   导致 CRLF 之后的内容当成了 body

2. 为什么绝大数情况下都在“:”后只用一个空格？  
   过多的空格就会浪费更多字节，数据传输总是希望更短的时间内传输更多数据

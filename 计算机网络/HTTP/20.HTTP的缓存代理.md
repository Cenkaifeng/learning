<!-- TOC -->

- [序言](#序言)
- [缓存代理服务](#缓存代理服务)
- [源服务器的缓存控制](#源服务器的缓存控制)
- [客户端的缓存控制](#客户端的缓存控制)
- [其他问题](#其他问题)
- [小结](#小结)
- [问题](#问题)

<!-- /TOC -->

## 序言

缓存代理，就是支持缓存控制的代理服务

## 缓存代理服务

![缓存代理](http://ww1.sinaimg.cn/large/68307314gy1gf116mr9bcj217w0l1ads.jpg)

代理服务收到源服务器发来的响应数据后需要做两件事：

1. 把报文转发给客户端
2. 把报文存入自己的 Cache

所以，下次再有同样的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器获取。这样就降低了客户端的等待时间，同时节约了源服务器的网络带宽

缓存代理的身份只是一个数据的“中转站”，所以缓存代理控制分为两部分，一是源服务器端的控制，二是客户端的控制

## 源服务器的缓存控制

之前讲述 HTTP 的缓存控制介绍过“Cache-Control”的属性，而其中“private”、“public”、“proxy-revalidate”、“s-maxage”、“no-transform”让缓存服务器使用

完整的服务器端缓存控制策略，如下：
![服务器端缓存控制策略](http://ww1.sinaimg.cn/large/68307314gy1gf11mg63rmj20tw1dedkd.jpg)

## 客户端的缓存控制

“Cache-Control”还有 3 个属性为客户端使用，关于缓存的生存时间“max-stale”和“min-fresh”，以及“only-if-cached”

客户端在 HTTP 缓存体系里要面对的是代理和源服务器，如图：
![客户端的缓存控制策略](http://ww1.sinaimg.cn/large/68307314gy1gf11o3cqkcj20u61enaec.jpg)

## 其他问题

1. Vary  
   是内容协商的结果，相当于报文的一个版本标记

   操作是这样的：  
   当收到同样请求时，代理读取缓存里的“Vary”，对比请求头的“Accept-Encoding”“User-Agent”等字段，如果和上一个请求完全匹配，就可以返回缓存数据

2. Purge  
   表示缓存清理。常见功能，如下：

   - 过期数据淘汰，避免占用空间
   - 源站的资源更新，删除旧版本，主动更新版本
   - 删除不安全的数据，如危险链接等

   也可以通过自定义请求方法“PURGE”，发给代理服务器，要求删除对应的缓存数据

## 小结

1. 计算机领域常用的性能优化手段是“时间转换”，也就是“时间换空间”或者“空间换时间”，缓存属于后者

2. 缓存代理是增加了缓存功能的代理服务，缓存源服务器的数据，分发给下游的客户端

3. Cache-Control”字段也可以控制缓存代理，常用的有“private”“s-maxage”“no-transform”等，同样必须配合“Last-modified”“ETag”等字段才能使用

4. 缓存代理有时候也带来负面影响，缓存不良数据，需要及时刷新或删除

## 问题

1. 加入了代理后 HTTP 的缓存复杂了很多，试着用自己的语言把这些知识再整理一下，画出有缓存代理时浏览器的工作流程图，加深理解

2. 缓存的时间策略很重要，太大太小都不好，你觉得应该如何设置呢？  
   需要根据场景，设置不同的策略  
   如果缓存的内容不变，那可以把缓存时间设置为永久  
   如果缓存的内容会变化，但周期较长，可以根据她的变化周期来设置，比如：一天或一周  
   如果缓存的内容变化频繁，那缓存的过期时间就需要更短了，比如：一分钟  
   如果缓存的内容随时变化，且没啥规律，那还是不用用了
